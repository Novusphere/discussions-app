{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/esm/initializerWarningHelper\";\n\nvar _dec, _dec2, _dec3, _dec4, _dec5, _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _class2, _temp;\n\nimport { BaseStore, getOrCreateStore } from 'next-mobx-wrapper';\nimport { action, computed, observable, reaction } from 'mobx';\nimport { task } from 'mobx-task';\nimport { getNewAuthStore } from \"./index\";\nimport { discussions } from \"../novusphere-js\";\nimport { persist } from 'mobx-persist';\nimport FeedModel from \"../models/feedModel\";\nimport { sleep } from \"../utils\";\nvar Notifications = (_dec = action.bound, _dec2 = action.bound, _dec3 = action.bound, _dec4 = action.bound, _dec5 = action.bound, (_class = (_temp = _class2 =\n/*#__PURE__*/\nfunction (_BaseStore) {\n  _inherits(Notifications, _BaseStore);\n\n  // the time last checked\n  // set default\n  function Notifications() {\n    var _this;\n\n    _classCallCheck(this, Notifications);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Notifications).call(this));\n\n    _initializerDefineProperty(_this, \"lastCheckedNotifications\", _descriptor, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"cursorId\", _descriptor2, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"notifications\", _descriptor3, _assertThisInitialized(_this));\n\n    _initializerDefineProperty(_this, \"unreadCount\", _descriptor4, _assertThisInitialized(_this));\n\n    _this.authStore = getNewAuthStore();\n    reaction(function () {\n      return _this.authStore.hasAccount;\n    }, function (hasAccount) {\n      if (hasAccount) {\n        _this.fetchNotifications();\n      }\n    }, {\n      fireImmediately: true\n    });\n    return _this;\n  }\n\n  _createClass(Notifications, [{\n    key: \"setTimeStamp\",\n    value: function setTimeStamp() {\n      this.lastCheckedNotifications = Date.now();\n    }\n  }, {\n    key: \"resetUnreadCount\",\n    value: function resetUnreadCount() {\n      this.unreadCount = 0;\n    }\n  }, {\n    key: \"clearNotifications\",\n    value: function clearNotifications() {\n      this.resetUnreadCount();\n      this.notifications.clear();\n      this.cursorId = 0;\n    }\n  }, {\n    key: \"fetchNotifications\",\n    value: function () {\n      var _fetchNotifications = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        var _this2 = this;\n\n        var time,\n            defaultCursorId,\n            _ref,\n            payload,\n            cursorId,\n            _args = arguments;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                time = _args.length > 0 && _args[0] !== undefined ? _args[0] : this.lastCheckedNotifications;\n                defaultCursorId = this.cursorId;\n\n                if (defaultCursorId === 0) {\n                  defaultCursorId = undefined;\n                }\n\n                _context.prev = 3;\n                _context.next = 6;\n                return discussions.getPostsForNotifications(this.authStore.activePublicKey, time, defaultCursorId);\n\n              case 6:\n                _ref = _context.sent;\n                payload = _ref.payload;\n                cursorId = _ref.cursorId;\n\n                if (!(time === 0)) {\n                  _context.next = 15;\n                  break;\n                }\n\n                this.lastCheckedNotifications = Date.now();\n                this.cursorId = cursorId;\n                return _context.abrupt(\"return\", payload);\n\n              case 15:\n                payload.forEach(function (notification) {\n                  _this2.notifications.set(notification.uuid, notification);\n                });\n                this.lastCheckedNotifications = Date.now();\n                this.cursorId = cursorId;\n                this.unreadCount = this.notifications.size;\n\n              case 19:\n                return _context.abrupt(\"return\", payload);\n\n              case 22:\n                _context.prev = 22;\n                _context.t0 = _context[\"catch\"](3);\n                throw _context.t0;\n\n              case 25:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this, [[3, 22]]);\n      }));\n\n      function fetchNotifications() {\n        return _fetchNotifications.apply(this, arguments);\n      }\n\n      return fetchNotifications;\n    }()\n  }, {\n    key: \"fetchNotificationsAsFeed\",\n    value: function () {\n      var _fetchNotificationsAsFeed = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2() {\n        var payload;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.prev = 0;\n                _context2.next = 3;\n                return sleep(500);\n\n              case 3:\n                _context2.next = 5;\n                return this.fetchNotifications(0);\n\n              case 5:\n                payload = _context2.sent;\n                return _context2.abrupt(\"return\", payload.map(function (post) {\n                  return new FeedModel(post);\n                }));\n\n              case 9:\n                _context2.prev = 9;\n                _context2.t0 = _context2[\"catch\"](0);\n                throw _context2.t0;\n\n              case 12:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this, [[0, 9]]);\n      }));\n\n      function fetchNotificationsAsFeed() {\n        return _fetchNotificationsAsFeed.apply(this, arguments);\n      }\n\n      return fetchNotificationsAsFeed;\n    }()\n  }, {\n    key: \"notificationsAsArray\",\n    get: function get() {\n      return Array.from(this.notifications.values());\n    }\n  }, {\n    key: \"firstSetOfNotifications\",\n    get: function get() {\n      return this.notificationsAsArray.slice(0, Notifications.notificationMaximumCount - 1);\n    }\n  }, {\n    key: \"hasMoreThanQueriedNotifications\",\n    get: function get() {\n      return this.cursorId !== 0;\n    }\n  }, {\n    key: \"hasNotifications\",\n    get: function get() {\n      return this.unreadCount > 0;\n    }\n  }, {\n    key: \"notificationCount\",\n    get: function get() {\n      var count = this.unreadCount;\n\n      if (count > Notifications.notificationMaximumCount) {\n        return \"\".concat(Notifications.notificationMaximumCount, \"+\");\n      }\n\n      return count;\n    }\n  }]);\n\n  return Notifications;\n}(BaseStore), _class2.notificationMaximumCount = 5, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"lastCheckedNotifications\", [persist, observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return -1;\n  }\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"cursorId\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 0;\n  }\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"notifications\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return observable.map();\n  }\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"unreadCount\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    return 0;\n  }\n}), _applyDecoratedDescriptor(_class.prototype, \"notificationsAsArray\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"notificationsAsArray\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"firstSetOfNotifications\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"firstSetOfNotifications\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"hasMoreThanQueriedNotifications\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"hasMoreThanQueriedNotifications\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"hasNotifications\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"hasNotifications\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"notificationCount\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"notificationCount\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"setTimeStamp\", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, \"setTimeStamp\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"resetUnreadCount\", [_dec2], Object.getOwnPropertyDescriptor(_class.prototype, \"resetUnreadCount\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"clearNotifications\", [_dec3], Object.getOwnPropertyDescriptor(_class.prototype, \"clearNotifications\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"fetchNotifications\", [task, _dec4], Object.getOwnPropertyDescriptor(_class.prototype, \"fetchNotifications\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"fetchNotificationsAsFeed\", [task, _dec5], Object.getOwnPropertyDescriptor(_class.prototype, \"fetchNotificationsAsFeed\"), _class.prototype)), _class));\nexport { Notifications as default };\nexport var getNotificationsStore = getOrCreateStore('notificationsStore', Notifications);","map":null,"metadata":{},"sourceType":"module"}