{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/esm/initializerWarningHelper\";\n\nvar _dec, _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _temp;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport Thread from \"../novusphere-js/discussions/thread\";\nimport { Post } from \"../novusphere-js/discussions/post\";\nimport { action, computed, observable } from 'mobx';\nimport { computedFn } from 'mobx-utils';\nimport { ReplyModel } from \"./replyModel\";\nimport _ from 'lodash';\nimport PostModel from \"./postModel\";\nimport { discussions } from \"../novusphere-js\"; // import { discussions } from '@novuspherejs'\n\nexport let ThreadModel = (_dec = observable.deep, (_class = (_temp = class ThreadModel {\n  get totalReplies() {\n    const map = Object.keys(this.map);\n\n    if (map.length) {\n      return map.length - 1;\n    }\n\n    return 0;\n  }\n  /**\r\n   * Get the reply box model for a particular post uid\r\n   * @return {ReplyModel}\r\n   */\n\n\n  /**\r\n   * ReplyBox box open status for a particular post id\r\n   */\n  constructor(thread) {\n    _initializerDefineProperty(this, \"map\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"openingPost\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"uuid\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"title\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"sub\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"replies\", _descriptor6, this);\n\n    this.replyBoxStatuses = observable.map();\n    this.rbModel = computedFn(post => {\n      const uid = post.uuid;\n\n      if (this.replyBoxStatuses.has(uid)) {\n        return this.replyBoxStatuses.get(uid);\n      }\n\n      let model;\n\n      if (this.map[uid]) {\n        model = new ReplyModel(this.map[uid], this.map);\n      } else {\n        model = new ReplyModel(post, this.map);\n      }\n\n      this.replyBoxStatuses.set(uid, model);\n      return model;\n    });\n    this.getRepliesFromMap = computedFn(uid => {\n      if (this.map[uid]) {\n        return _.filter(this.map, (post, index) => post.parentUuid === uid);\n      }\n\n      return [];\n    });\n\n    this.toggleReplyBoxStatus = uid => {\n      let replyModel;\n\n      if (this.replyBoxStatuses.has(uid)) {\n        replyModel = this.replyBoxStatuses.get(uid);\n        replyModel.toggleOpen();\n        this.replyBoxStatuses.set(uid, replyModel);\n      } else {\n        if (this.map[uid]) {\n          this.replyBoxStatuses.set(uid, new ReplyModel(this.map[uid], this.map));\n        }\n      }\n    };\n\n    _initializerDefineProperty(this, \"vote\", _descriptor7, this);\n\n    if (!(thread instanceof Post) || thread instanceof Thread) {\n      this.openingPost = new PostModel(thread.openingPost);\n      this.uuid = thread.openingPost.uuid;\n      const map = {};\n      Object.keys(thread.map).map(id => {\n        map[id] = new PostModel(thread.map[id]);\n      });\n      this.map = map;\n      this.title = thread.openingPost.title;\n      this.sub = thread.openingPost.sub;\n    } else {\n      this.openingPost = thread;\n      this.uuid = thread.uuid;\n      this.title = thread.title;\n    }\n    /**\r\n     * Set reply box open for the opening post by default\r\n     */\n\n\n    const openingPostReplyModel = new ReplyModel(this.openingPost, this.map);\n    openingPostReplyModel.toggleOpen();\n    this.replyBoxStatuses.set(this.uuid, openingPostReplyModel);\n  }\n\n  get openingPostReplies() {\n    const openingPostReplies = this.getRepliesFromMap(this.uuid);\n    return openingPostReplies.map(reply => {\n      return _objectSpread({}, reply, {\n        replies: this.getRepliesFromMap(reply.uuid)\n      });\n    });\n  }\n  /**\r\n   * Toggle the status of the reply box\r\n   * @param {string} uid\r\n   * @return {void}\r\n   */\n\n\n}, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"map\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"openingPost\", [_dec], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"uuid\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"title\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, \"sub\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, \"replies\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _applyDecoratedDescriptor(_class.prototype, \"totalReplies\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"totalReplies\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"openingPostReplies\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"openingPostReplies\"), _class.prototype), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, \"vote\", [action], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return async (uuid, myNewVote) => {\n      const type = myNewVote === 1 ? 'upvotes' : 'downvotes';\n\n      try {\n        await discussions.vote(uuid, myNewVote); // opening post\n\n        if (uuid === this.uuid) {\n          if (this.openingPost['myVote'] === 0) {\n            this.openingPost[type] = this.openingPost[type] + myNewVote;\n            this.openingPost['myVote'] = myNewVote;\n          } else if (this.openingPost['myVote'] === 1) {\n            this.openingPost['upvotes'] = this.openingPost['upvotes'] - 1;\n            this.openingPost['myVote'] = 0;\n          } else if (this.openingPost['myVote'] === -1) {\n            this.openingPost['downvotes'] = this.openingPost['downvotes'] + 1;\n            this.openingPost['myVote'] = 0;\n          }\n        }\n\n        if (this.map) {\n          if (this.map[uuid].myVote === 0) {\n            this.map[uuid][type] = this.map[uuid][type] + myNewVote;\n            this.map[uuid].myVote = myNewVote;\n          } else if (this.map[uuid].myVote === 1) {\n            this.map[uuid]['upvotes'] = this.map[uuid]['upvotes'] - 1;\n            this.map[uuid].myVote = 0;\n          } else if (this.map[uuid].myVote === -1) {\n            this.map[uuid]['downvotes'] = this.map[uuid]['downvotes'] + 1;\n            this.map[uuid].myVote = 0;\n          }\n        }\n      } catch (error) {\n        console.log(error);\n        throw error;\n      }\n    };\n  }\n})), _class));","map":null,"metadata":{},"sourceType":"module"}