{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\n//@ts-ignore\nimport ecc from 'eosjs-ecc';\nimport { Attachment } from \"./attachment\";\n\nvar BigInt = require('big-integer');\n\nexport var Post =\n/*#__PURE__*/\nfunction () {\n  _createClass(Post, [{\n    key: \"hasAttachment\",\n    // Blockchain Specific\n    // may not be the *exact* block the transaction occured in but \"near\" this block\n    // Post Data\n    // Discussion ID Post Data\n    // Attachment\n    // Children (thread format)\n    // State Data\n    // only used if isOpeningPost()\n    // only used if isOpeningPost()\n    // only used if Thread object created with\n    // Aggregate Data\n    value: function hasAttachment() {\n      return this.attachment.value != '' && this.attachment.type != '' && this.attachment.display != '';\n    }\n  }, {\n    key: \"isOpeningPost\",\n    value: function isOpeningPost() {\n      return this.parentUuid == '';\n    }\n  }, {\n    key: \"isAnonymousVerified\",\n    value: function isAnonymousVerified() {\n      if (!this.verifySig) {\n        if (!ecc.isValidPublic(this.pub)) {\n          this.verifySig = 'INVALID_PUB_KEY';\n          return false;\n        }\n\n        this.verifySig = ecc.recover(this.sig, this.content);\n      }\n\n      return this.verifySig == this.pub;\n    }\n  }]);\n\n  function Post(chain) {\n    _classCallCheck(this, Post);\n\n    this.id = void 0;\n    this.transaction = void 0;\n    this.blockApprox = void 0;\n    this.chain = void 0;\n    this.parentUuid = void 0;\n    this.threadUuid = void 0;\n    this.uuid = void 0;\n    this.title = void 0;\n    this.poster = void 0;\n    this.displayName = void 0;\n    this.content = void 0;\n    this.createdAt = void 0;\n    this.sub = void 0;\n    this.tags = void 0;\n    this.mentions = void 0;\n    this.edit = void 0;\n    this.pub = void 0;\n    this.sig = void 0;\n    this.verifySig = void 0;\n    this.attachment = void 0;\n    this.replies = void 0;\n    this.totalReplies = void 0;\n    this.score = void 0;\n    this.upvotes = void 0;\n    this.downvotes = void 0;\n    this.depth = void 0;\n    this.myVote = void 0;\n    this.id = Math.random() * 0xFFFFFFFF | 0; // generate random string id\n\n    this.transaction = '';\n    this.blockApprox = 0;\n    this.chain = chain;\n    this.parentUuid = '';\n    this.threadUuid = '';\n    this.uuid = '';\n    this.title = '';\n    this.poster = '';\n    this.displayName = '';\n    this.content = '';\n    this.createdAt = new Date(0);\n    this.sub = '';\n    this.tags = [];\n    this.mentions = [];\n    this.edit = false;\n    this.pub = '';\n    this.sig = '';\n    this.verifySig = '';\n    this.attachment = new Attachment();\n    this.replies = [];\n    this.totalReplies = 0;\n    this.score = 0;\n    this.upvotes = 0;\n    this.downvotes = 0;\n    this.depth = 0;\n    this.myVote = 0;\n  }\n\n  _createClass(Post, [{\n    key: \"encodeId\",\n    value: function encodeId() {\n      return Post.encodeId(this.transaction, this.createdAt);\n    }\n  }, {\n    key: \"sign\",\n    value: function sign(privKey) {\n      this.pub = ecc.privateToPublic(privKey); // const hash = ecc.sha256(this.uuid+ecc.sha256(this.content))\n\n      var hash0 = ecc.sha256(this.content);\n      var hash1 = ecc.sha256(this.uuid + hash0);\n      console.log('Class: Post, Function: sign, Line 168 this.content: ', this.content);\n      console.log('Class: Post, Function: sign, Line 169 this.uuid: ', this.uuid);\n      console.log('Class: Post, Function: sign, Line 168 hash0: ', hash0);\n      console.log('Class: Post, Function: sign, Line 169 hash1: ', hash1);\n      this.sig = ecc.sign(hash1, privKey);\n      this.verifySig = this.pub;\n    }\n    /*applyEdit(p: Post) {\r\n        if (!p.edit || p.parentUuid != this.uuid) return;\r\n        if (p.chain != this.chain) return;\r\n        if (p.poster != this.poster) return;\r\n        if (this.anonymousId || p.anonymousId) {\r\n            if (p.anonymousId != this.anonymousId) return;\r\n            if (!this.isAnonymousVerified() || !p.isAnonymousVerified()) return;\r\n        }\r\n          this.content = p.content;\r\n        this.createdAt = p.createdAt;\r\n        this.tags = p.tags;\r\n        this.mentions = p.mentions;\r\n        this.edit = true;\r\n          this.anonymousId = p.anonymousId;\r\n        this.anonymousSignature = p.anonymousSignature;\r\n        this.verifyAnonymousSignature = p.verifyAnonymousSignature;\r\n          this.attachment = p.attachment;\r\n    }*/\n\n  }, {\n    key: \"autoImage\",\n    value: function autoImage() {\n      if (!this.content) return;\n      var IMAGE_URL = /(.|)http[s]?:\\/\\/(\\w|[:\\/\\.%-])+\\.(png|jpg|jpeg|gif)(\\?(\\w|[:\\/\\.%-])+)?(.|)/gi;\n      this.content = this.content.replace(IMAGE_URL, function (link) {\n        var trimmedLink = link.trim();\n\n        if (!trimmedLink.startsWith('http')) {\n          return link;\n        }\n\n        return \"![](\".concat(trimmedLink, \")\");\n      });\n    }\n  }, {\n    key: \"normalize\",\n    value: function () {\n      var _normalize = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee() {\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                this.autoImage();\n                _context.next = 3;\n                return this.attachment.normalize();\n\n              case 3:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function normalize() {\n        return _normalize.apply(this, arguments);\n      }\n\n      return normalize;\n    }()\n  }], [{\n    key: \"fromDbObject\",\n    value: function fromDbObject(o) {\n      var p = new Post(o.chain);\n      p.id = o.id;\n      p.transaction = o.transaction;\n      p.blockApprox = o.blockApprox;\n      p.uuid = o.uuid;\n      p.parentUuid = o.parentUuid;\n      p.threadUuid = o.threadUuid;\n      p.title = o.title;\n      p.poster = o.poster;\n      p.displayName = o.displayName;\n      p.content = o.content;\n      p.createdAt = new Date(o.createdAt);\n      p.sub = o.sub;\n      p.tags = o.tags;\n      p.mentions = o.mentions;\n      p.edit = o.edit;\n      p.pub = o.pub;\n      p.sig = o.sig;\n\n      if (o.attachment) {\n        p.attachment.value = o.attachment.value || p.attachment.value;\n        p.attachment.type = o.attachment.type || p.attachment.type;\n        p.attachment.display = o.attachment.display || p.attachment.display;\n      }\n\n      p.totalReplies = o.totalReplies;\n      p.upvotes = o.upvotes;\n      p.downvotes = o.downvotes;\n\n      if (o.myVote && o.myVote.length > 0) {\n        p.myVote = o.myVote[0].value;\n      }\n\n      return p;\n    }\n  }, {\n    key: \"decodeId\",\n    value: function decodeId(id) {\n      var n = new BigInt(id, 36);\n      var txid32 = n.shiftRight(32).toString(16).padStart(8, '0');\n      var timeOffset = n.and(new BigInt('ffffffff', 16));\n      var time = timeOffset.valueOf() * 1000 + new Date('2017/1/1').getTime();\n      return {\n        txid32: txid32,\n        timeGte: time - 1000 * 60 * 3,\n        timeLte: time + 1000 * 60 * 3\n      };\n    }\n  }, {\n    key: \"encodeId\",\n    value: function encodeId(transaction, createdAt) {\n      var txid32 = new BigInt(transaction.substring(0, 8), 16);\n      var timeOffset = new BigInt(Math.floor((createdAt.getTime() - new Date('2017/1/1').getTime()) / 1000), 10);\n      var id = txid32.shiftLeft(32).or(timeOffset);\n      return id.toString(36);\n    }\n  }]);\n\n  return Post;\n}();","map":null,"metadata":{},"sourceType":"module"}