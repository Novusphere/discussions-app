{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/esm/toConsumableArray\";\nimport _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { Post } from \"../post\";\nimport Thread from \"../thread\";\nimport { eos, nsdb } from \"../..\";\n\nvar aesjs = require('aes-js'); //const crypto = require('crypto');\n\n\nvar bip39 = require('bip39');\n\nimport * as bip32 from 'bip32';\nimport ecc from 'eosjs-ecc';\nimport axios from 'axios';\n\nvar DiscussionsService =\n/*#__PURE__*/\nfunction () {\n  function DiscussionsService() {\n    _classCallCheck(this, DiscussionsService);\n  }\n\n  _createClass(DiscussionsService, [{\n    key: \"bkCreate\",\n    value: function bkCreate() {\n      return bip39.generateMnemonic();\n    }\n  }, {\n    key: \"bkIsValid\",\n    value: function bkIsValid(bk) {\n      return bip39.validateMnemonic(bk);\n    }\n    /*private bkGetBitcoin(node: bip32.BIP32Interface) {\r\n          function hash160(data: Buffer) {\r\n            var hash = crypto.createHash('ripemd160');\r\n            let res = hash.update(data);\r\n            return res.digest();\r\n        }\r\n          return;\r\n    }*/\n\n  }, {\n    key: \"aesEncrypt\",\n    value: function aesEncrypt(data, password) {\n      var key = aesjs.utils.hex.toBytes(ecc.sha256(password));\n      var textBytes = aesjs.utils.utf8.toBytes(data);\n      var aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));\n      var encryptedBytes = aesCtr.encrypt(textBytes);\n      var encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\n      return encryptedHex;\n    }\n  }, {\n    key: \"aesDecrypt\",\n    value: function aesDecrypt(data, password) {\n      var key = aesjs.utils.hex.toBytes(ecc.sha256(password));\n      var aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));\n      var encryptedBytes = aesjs.utils.hex.toBytes(data);\n      var decryptedBytes = aesCtr.decrypt(encryptedBytes);\n      var decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\n      return decryptedText;\n    }\n  }, {\n    key: \"bkFromStatusJson\",\n    value: function bkFromStatusJson(statusJson, password) {\n      console.log('bkFromStatusJSON un-parsed:', statusJson);\n      var status;\n\n      if (statusJson === 'test') {\n        status = statusJson;\n      } else {\n        status = JSON.parse(statusJson);\n      }\n\n      console.log('bkFromStatusJSON parsed:', status);\n      var bkc = status['bkc'];\n      var bk = status['bk'];\n      if (!bkc || !bk) throw new Error('No brian key found');\n      var test = this.aesDecrypt(bkc, password);\n      if (test != 'test') throw new Error('Incorrect brian key pasword');\n      return this.aesDecrypt(bk, password);\n    }\n  }, {\n    key: \"bkToStatusJson\",\n    value: function () {\n      var _bkToStatusJson = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee(bk, displayName, password, status) {\n        var keys, k;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (!status) status = {};\n                _context.next = 3;\n                return this.bkToKeys(bk);\n\n              case 3:\n                keys = _context.sent;\n\n                for (k in keys) {\n                  status[k] = keys[k].pub;\n                }\n\n                status['displayName'] = displayName;\n                status['bk'] = this.aesEncrypt(bk, password);\n                status['bkc'] = this.aesEncrypt('test', password);\n                return _context.abrupt(\"return\", JSON.stringify(status));\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function bkToStatusJson(_x, _x2, _x3, _x4) {\n        return _bkToStatusJson.apply(this, arguments);\n      }\n\n      return bkToStatusJson;\n    }()\n  }, {\n    key: \"bkGetEOS\",\n    value: function bkGetEOS(node, n) {\n      var child = node.derivePath(\"m/80'/0'/0'/\".concat(n));\n      var wif = child.toWIF();\n      return {\n        priv: wif,\n        pub: ecc.privateToPublic(wif)\n      };\n    }\n  }, {\n    key: \"bkToKeys\",\n    value: function () {\n      var _bkToKeys = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee2(bk) {\n        var seed, node, keys;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return bip39.mnemonicToSeed(bk);\n\n              case 2:\n                seed = _context2.sent;\n                _context2.next = 5;\n                return bip32.fromSeed(seed);\n\n              case 5:\n                node = _context2.sent;\n                keys = {\n                  post: null,\n                  tip: null\n                }; //keys['BTC'] = this.bkGetBitcoin(node);\n\n                keys['post'] = this.bkGetEOS(node, 0);\n                keys['tip'] = this.bkGetEOS(node, 1);\n                return _context2.abrupt(\"return\", keys);\n\n              case 10:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function bkToKeys(_x5) {\n        return _bkToKeys.apply(this, arguments);\n      }\n\n      return bkToKeys;\n    }()\n  }, {\n    key: \"getPostsForSearch\",\n    value: function () {\n      var _getPostsForSearch = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee3(search) {\n        var query;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                _context3.next = 2;\n                return nsdb.search({\n                  query: {\n                    $text: {\n                      $search: search\n                    }\n                  },\n                  sort: {\n                    createdAt: -1\n                  },\n                  account: eos.accountName || ''\n                });\n\n              case 2:\n                query = _context3.sent;\n                return _context3.abrupt(\"return\", query.payload.map(function (o) {\n                  return Post.fromDbObject(o);\n                }));\n\n              case 4:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3);\n      }));\n\n      function getPostsForSearch(_x6) {\n        return _getPostsForSearch.apply(this, arguments);\n      }\n\n      return getPostsForSearch;\n    }()\n  }, {\n    key: \"bkRetrieveStatusEOS\",\n    value: function () {\n      var _bkRetrieveStatusEOS = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee4(account) {\n        var result;\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                _context4.next = 2;\n                return eos.api.rpc.get_table_rows({\n                  code: 'discussionsx',\n                  scope: 'discussionsx',\n                  table: 'status',\n                  lower_bound: account,\n                  upper_bound: account\n                });\n\n              case 2:\n                result = _context4.sent;\n\n                if (!(result.rows.length == 0)) {\n                  _context4.next = 5;\n                  break;\n                }\n\n                return _context4.abrupt(\"return\", undefined);\n\n              case 5:\n                return _context4.abrupt(\"return\", result.rows[0].content);\n\n              case 6:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4);\n      }));\n\n      function bkRetrieveStatusEOS(_x7) {\n        return _bkRetrieveStatusEOS.apply(this, arguments);\n      }\n\n      return bkRetrieveStatusEOS;\n    }()\n  }, {\n    key: \"bkUpdateStatusEOS\",\n    value: function () {\n      var _bkUpdateStatusEOS = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee5(statusJson) {\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                _context5.prev = 0;\n\n                if (!(eos.auth && eos.auth.accountName)) {\n                  _context5.next = 5;\n                  break;\n                }\n\n                _context5.next = 4;\n                return eos.transact({\n                  account: 'discussionsx',\n                  name: 'status',\n                  data: {\n                    account: eos.auth.accountName,\n                    content: statusJson\n                  }\n                });\n\n              case 4:\n                return _context5.abrupt(\"return\", _context5.sent);\n\n              case 5:\n                _context5.next = 10;\n                break;\n\n              case 7:\n                _context5.prev = 7;\n                _context5.t0 = _context5[\"catch\"](0);\n                throw _context5.t0;\n\n              case 10:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, null, [[0, 7]]);\n      }));\n\n      function bkUpdateStatusEOS(_x8) {\n        return _bkUpdateStatusEOS.apply(this, arguments);\n      }\n\n      return bkUpdateStatusEOS;\n    }()\n  }, {\n    key: \"vote\",\n    value: function () {\n      var _vote = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee6(uuid, value) {\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _context6.prev = 0;\n\n                if (!(eos.auth && eos.auth.accountName)) {\n                  _context6.next = 5;\n                  break;\n                }\n\n                _context6.next = 4;\n                return eos.transact({\n                  account: 'discussionsx',\n                  name: 'vote',\n                  data: {\n                    voter: eos.auth.accountName,\n                    uuid: uuid,\n                    value: value\n                  }\n                });\n\n              case 4:\n                return _context6.abrupt(\"return\", _context6.sent);\n\n              case 5:\n                _context6.next = 10;\n                break;\n\n              case 7:\n                _context6.prev = 7;\n                _context6.t0 = _context6[\"catch\"](0);\n                throw _context6.t0;\n\n              case 10:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, null, [[0, 7]]);\n      }));\n\n      function vote(_x9, _x10) {\n        return _vote.apply(this, arguments);\n      }\n\n      return vote;\n    }()\n  }, {\n    key: \"post\",\n    value: function () {\n      var _post = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee7(p) {\n        var tags, mentions, metadata, post, _ref, data, transaction;\n\n        return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n          while (1) {\n            switch (_context7.prev = _context7.next) {\n              case 0:\n                if (!(p.chain != 'eos')) {\n                  _context7.next = 2;\n                  break;\n                }\n\n                throw new Error('Unknown chain');\n\n              case 2:\n                tags = new Set();\n                [p.sub].concat(_toConsumableArray(p.tags)).forEach(function (t) {\n                  return tags.add(t.toLowerCase());\n                });\n                mentions = new Set();\n                p.mentions.forEach(function (u) {\n                  return mentions.add(u);\n                });\n                metadata = {};\n                if (p.title) metadata.title = p.title;\n                if (p.attachment.value) metadata.attachment = p.attachment;\n\n                if (p.pub && p.sig) {\n                  metadata.pub = p.pub;\n                  metadata.sig = p.sig;\n                }\n\n                metadata.displayName = p.displayName || p.poster;\n                metadata.mentions = Array.from(mentions);\n                post = {\n                  poster: p.poster,\n                  content: p.content,\n                  uuid: p.uuid,\n                  threadUuid: p.threadUuid,\n                  parentUuid: p.parentUuid,\n                  tags: Array.from(tags),\n                  mentions: [],\n                  metadata: JSON.stringify(metadata),\n                  transaction: ''\n                };\n                _context7.prev = 13;\n\n                if (p.poster) {\n                  _context7.next = 24;\n                  break;\n                }\n\n                console.log('no poster found, posting as anon');\n                _context7.next = 18;\n                return axios.get(\"\".concat(nsdb.api, \"/discussions/post\"), {\n                  params: {\n                    data: JSON.stringify(post)\n                  }\n                });\n\n              case 18:\n                _ref = _context7.sent;\n                data = _ref.data;\n                console.log('Class: DiscussionsService, Function: post, Line 219 data: ', data);\n                p.transaction = data.transaction;\n                _context7.next = 29;\n                break;\n\n              case 24:\n                console.log('poster found, opening Scatter to confirm');\n                _context7.next = 27;\n                return eos.transact([{\n                  account: 'discussionsx',\n                  name: 'post',\n                  data: post\n                }, {\n                  account: 'discussionsx',\n                  // self up vote\n                  name: 'vote',\n                  data: {\n                    voter: p.poster,\n                    uuid: p.uuid,\n                    value: 1\n                  }\n                }]);\n\n              case 27:\n                transaction = _context7.sent;\n                p.transaction = transaction;\n\n              case 29:\n                console.log('transaction set: !', p.transaction);\n                p.myVote = 1;\n                return _context7.abrupt(\"return\", p);\n\n              case 34:\n                _context7.prev = 34;\n                _context7.t0 = _context7[\"catch\"](13);\n                console.error(_context7.t0);\n                throw _context7.t0;\n\n              case 38:\n              case \"end\":\n                return _context7.stop();\n            }\n          }\n        }, _callee7, null, [[13, 34]]);\n      }));\n\n      function post(_x11) {\n        return _post.apply(this, arguments);\n      }\n\n      return post;\n    }()\n  }, {\n    key: \"getThread\",\n    value: function () {\n      var _getThread = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee8(_id) {\n        var dId, sq, posts, op, thread;\n        return _regeneratorRuntime.wrap(function _callee8$(_context8) {\n          while (1) {\n            switch (_context8.prev = _context8.next) {\n              case 0:\n                dId = Post.decodeId(_id);\n                _context8.next = 3;\n                return nsdb.search({\n                  query: {\n                    createdAt: {\n                      $gte: dId.timeGte,\n                      $lte: dId.timeLte\n                    },\n                    transaction: {\n                      $regex: \"^\".concat(dId.txid32)\n                    }\n                  }\n                });\n\n              case 3:\n                sq = _context8.sent;\n\n                if (!(sq.payload.length == 0)) {\n                  _context8.next = 6;\n                  break;\n                }\n\n                return _context8.abrupt(\"return\", undefined);\n\n              case 6:\n                posts = [];\n                op = Post.fromDbObject(sq.payload[0]);\n                sq = {\n                  query: {\n                    threadUuid: op.threadUuid,\n                    sub: op.sub\n                  },\n                  account: eos.accountName || ''\n                };\n\n              case 9:\n                _context8.next = 11;\n                return nsdb.search(sq);\n\n              case 11:\n                sq = _context8.sent;\n                posts = [].concat(_toConsumableArray(posts), _toConsumableArray(sq.payload.map(function (o) {\n                  return Post.fromDbObject(o);\n                })));\n\n              case 13:\n                if (sq.cursorId) {\n                  _context8.next = 9;\n                  break;\n                }\n\n              case 14:\n                thread = new Thread();\n                thread.init(posts);\n                thread.normalize();\n                return _context8.abrupt(\"return\", thread);\n\n              case 18:\n              case \"end\":\n                return _context8.stop();\n            }\n          }\n        }, _callee8);\n      }));\n\n      function getThread(_x12) {\n        return _getThread.apply(this, arguments);\n      }\n\n      return getThread;\n    }()\n  }, {\n    key: \"getPostsForSubs\",\n    value: function () {\n      var _getPostsForSubs = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee9(subs) {\n        var q, query;\n        return _regeneratorRuntime.wrap(function _callee9$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                q = {\n                  $in: subs.map(function (sub) {\n                    return sub.toLowerCase();\n                  })\n                };\n\n                if (subs.length == 1 && subs[0] == 'all') {\n                  q = {\n                    $nin: []\n                  }; // filtered subs from all sub\n                }\n\n                _context9.next = 4;\n                return nsdb.search({\n                  query: {\n                    sub: q,\n                    parentUuid: '' // top-level only\n\n                  },\n                  sort: {\n                    createdAt: -1\n                  },\n                  account: eos.accountName || ''\n                });\n\n              case 4:\n                query = _context9.sent;\n                return _context9.abrupt(\"return\", query.payload.map(function (o) {\n                  return Post.fromDbObject(o);\n                }));\n\n              case 6:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee9);\n      }));\n\n      function getPostsForSubs(_x13) {\n        return _getPostsForSubs.apply(this, arguments);\n      }\n\n      return getPostsForSubs;\n    }()\n  }, {\n    key: \"getPostsForTags\",\n    value: function () {\n      var _getPostsForTags = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee10(tags) {\n        var cursorId,\n            count,\n            limit,\n            threadOnly,\n            searchQuery,\n            query,\n            posts,\n            _args10 = arguments;\n        return _regeneratorRuntime.wrap(function _callee10$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                cursorId = _args10.length > 1 && _args10[1] !== undefined ? _args10[1] : undefined;\n                count = _args10.length > 2 && _args10[2] !== undefined ? _args10[2] : 0;\n                limit = _args10.length > 3 && _args10[3] !== undefined ? _args10[3] : 20;\n                threadOnly = _args10.length > 4 && _args10[4] !== undefined ? _args10[4] : true;\n                searchQuery = {\n                  query: {\n                    tags: {\n                      $in: tags.map(function (tag) {\n                        return tag.toLowerCase();\n                      })\n                    }\n                  },\n                  sort: {\n                    createdAt: -1\n                  },\n                  account: eos.accountName || '',\n                  cursorId: cursorId,\n                  count: count,\n                  limit: limit\n                };\n\n                if (threadOnly) {\n                  searchQuery.query['parentUuid'] = '';\n                }\n\n                _context10.next = 8;\n                return nsdb.search(searchQuery);\n\n              case 8:\n                query = _context10.sent;\n                posts = query.payload.map(function (o) {\n                  return Post.fromDbObject(o);\n                });\n                return _context10.abrupt(\"return\", {\n                  posts: posts,\n                  cursorId: query.cursorId\n                });\n\n              case 11:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee10);\n      }));\n\n      function getPostsForTags(_x14) {\n        return _getPostsForTags.apply(this, arguments);\n      }\n\n      return getPostsForTags;\n    }()\n    /**\r\n     * Returns all the posts in which the user was\r\n     * tagged in (mentions).\r\n     */\n\n  }, {\n    key: \"getPostsForNotifications\",\n    value: function () {\n      var _getPostsForNotifications = _asyncToGenerator(\n      /*#__PURE__*/\n      _regeneratorRuntime.mark(function _callee11(postPublicKey, lastCheckedNotifications) {\n        var cursorId,\n            _args11 = arguments;\n        return _regeneratorRuntime.wrap(function _callee11$(_context11) {\n          while (1) {\n            switch (_context11.prev = _context11.next) {\n              case 0:\n                cursorId = _args11.length > 2 && _args11[2] !== undefined ? _args11[2] : undefined;\n                _context11.prev = 1;\n                _context11.next = 4;\n                return nsdb.search({\n                  query: {\n                    createdAt: {\n                      $gte: lastCheckedNotifications\n                    },\n                    mentions: {\n                      $in: [postPublicKey]\n                    }\n                  },\n                  cursorId: cursorId\n                });\n\n              case 4:\n                return _context11.abrupt(\"return\", _context11.sent);\n\n              case 7:\n                _context11.prev = 7;\n                _context11.t0 = _context11[\"catch\"](1);\n                throw _context11.t0;\n\n              case 10:\n              case \"end\":\n                return _context11.stop();\n            }\n          }\n        }, _callee11, null, [[1, 7]]);\n      }));\n\n      function getPostsForNotifications(_x15, _x16) {\n        return _getPostsForNotifications.apply(this, arguments);\n      }\n\n      return getPostsForNotifications;\n    }()\n  }]);\n\n  return DiscussionsService;\n}();\n\nexport { DiscussionsService as default };\n;","map":null,"metadata":{},"sourceType":"module"}