{"ast":null,"code":"import { Post } from \"../post\";\nimport Thread from \"../thread\";\nimport { eos, nsdb } from \"../..\";\n\nconst aesjs = require('aes-js'); //const crypto = require('crypto');\n\n\nconst bip39 = require('bip39');\n\nimport * as bip32 from 'bip32';\nimport ecc from 'eosjs-ecc';\nimport axios from 'axios';\nexport default class DiscussionsService {\n  constructor() {}\n\n  bkCreate() {\n    return bip39.generateMnemonic();\n  }\n\n  bkIsValid(bk) {\n    return bip39.validateMnemonic(bk);\n  }\n  /*private bkGetBitcoin(node: bip32.BIP32Interface) {\r\n        function hash160(data: Buffer) {\r\n          var hash = crypto.createHash('ripemd160');\r\n          let res = hash.update(data);\r\n          return res.digest();\r\n      }\r\n        return;\r\n  }*/\n\n\n  aesEncrypt(data, password) {\n    var key = aesjs.utils.hex.toBytes(ecc.sha256(password));\n    var textBytes = aesjs.utils.utf8.toBytes(data);\n    var aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));\n    var encryptedBytes = aesCtr.encrypt(textBytes);\n    var encryptedHex = aesjs.utils.hex.fromBytes(encryptedBytes);\n    return encryptedHex;\n  }\n\n  aesDecrypt(data, password) {\n    var key = aesjs.utils.hex.toBytes(ecc.sha256(password));\n    var aesCtr = new aesjs.ModeOfOperation.ctr(key, new aesjs.Counter(5));\n    var encryptedBytes = aesjs.utils.hex.toBytes(data);\n    var decryptedBytes = aesCtr.decrypt(encryptedBytes);\n    var decryptedText = aesjs.utils.utf8.fromBytes(decryptedBytes);\n    return decryptedText;\n  }\n\n  bkFromStatusJson(statusJson, password) {\n    console.log('bkFromStatusJSON un-parsed:', statusJson);\n    let status;\n\n    if (statusJson === 'test') {\n      status = statusJson;\n    } else {\n      status = JSON.parse(statusJson);\n    }\n\n    console.log('bkFromStatusJSON parsed:', status);\n    let bkc = status['bkc'];\n    let bk = status['bk'];\n    if (!bkc || !bk) throw new Error('No brian key found');\n    let test = this.aesDecrypt(bkc, password);\n    if (test != 'test') throw new Error('Incorrect brian key pasword');\n    return this.aesDecrypt(bk, password);\n  }\n\n  async bkToStatusJson(bk, displayName, password, status) {\n    if (!status) status = {};\n    const keys = await this.bkToKeys(bk);\n\n    for (var k in keys) {\n      status[k] = keys[k].pub;\n    }\n\n    status['displayName'] = displayName;\n    status['bk'] = this.aesEncrypt(bk, password);\n    status['bkc'] = this.aesEncrypt('test', password);\n    return JSON.stringify(status);\n  }\n\n  bkGetEOS(node, n) {\n    let child = node.derivePath(`m/80'/0'/0'/${n}`);\n    const wif = child.toWIF();\n    return {\n      priv: wif,\n      pub: ecc.privateToPublic(wif)\n    };\n  }\n\n  async bkToKeys(bk) {\n    const seed = await bip39.mnemonicToSeed(bk);\n    const node = await bip32.fromSeed(seed);\n    const keys = {\n      post: null,\n      tip: null\n    }; //keys['BTC'] = this.bkGetBitcoin(node);\n\n    keys['post'] = this.bkGetEOS(node, 0);\n    keys['tip'] = this.bkGetEOS(node, 1);\n    return keys;\n  }\n\n  async getPostsForSearch(search) {\n    const query = await nsdb.search({\n      query: {\n        $text: {\n          $search: search\n        }\n      },\n      sort: {\n        createdAt: -1\n      },\n      account: eos.accountName || ''\n    });\n    return query.payload.map(o => Post.fromDbObject(o));\n  }\n\n  async bkRetrieveStatusEOS(account) {\n    let result = await eos.api.rpc.get_table_rows({\n      code: 'discussionsx',\n      scope: 'discussionsx',\n      table: 'status',\n      lower_bound: account,\n      upper_bound: account\n    });\n    if (result.rows.length == 0) return undefined;\n    return result.rows[0].content;\n  }\n\n  async bkUpdateStatusEOS(statusJson) {\n    try {\n      if (eos.auth && eos.auth.accountName) {\n        return await eos.transact({\n          account: 'discussionsx',\n          name: 'status',\n          data: {\n            account: eos.auth.accountName,\n            content: statusJson\n          }\n        });\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async vote(uuid, value) {\n    try {\n      if (eos.auth && eos.auth.accountName) {\n        return await eos.transact({\n          account: 'discussionsx',\n          name: 'vote',\n          data: {\n            voter: eos.auth.accountName,\n            uuid: uuid,\n            value: value\n          }\n        });\n      }\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async post(p) {\n    if (p.chain != 'eos') throw new Error('Unknown chain');\n    const tags = new Set();\n    [p.sub, ...p.tags].forEach(t => tags.add(t.toLowerCase()));\n    const mentions = new Set();\n    p.mentions.forEach(u => mentions.add(u));\n    const metadata = {};\n    if (p.title) metadata.title = p.title;\n    if (p.attachment.value) metadata.attachment = p.attachment;\n\n    if (p.pub && p.sig) {\n      metadata.pub = p.pub;\n      metadata.sig = p.sig;\n    }\n\n    metadata.displayName = p.displayName || p.poster;\n    metadata.mentions = Array.from(mentions);\n    const post = {\n      poster: p.poster,\n      content: p.content,\n      uuid: p.uuid,\n      threadUuid: p.threadUuid,\n      parentUuid: p.parentUuid,\n      tags: Array.from(tags),\n      mentions: [],\n      metadata: JSON.stringify(metadata),\n      transaction: ''\n    };\n\n    try {\n      if (!p.poster) {\n        console.log('no poster found, posting as anon');\n        const {\n          data\n        } = await axios.get(`${nsdb.api}/discussions/post`, {\n          params: {\n            data: JSON.stringify(post)\n          }\n        });\n        console.log('Class: DiscussionsService, Function: post, Line 219 data: ', data);\n        p.transaction = data.transaction;\n      } else {\n        console.log('poster found, opening Scatter to confirm');\n        const transaction = await eos.transact([{\n          account: 'discussionsx',\n          name: 'post',\n          data: post\n        }, {\n          account: 'discussionsx',\n          // self up vote\n          name: 'vote',\n          data: {\n            voter: p.poster,\n            uuid: p.uuid,\n            value: 1\n          }\n        }]);\n        p.transaction = transaction;\n      }\n\n      console.log('transaction set: !', p.transaction);\n      p.myVote = 1;\n      return p;\n    } catch (error) {\n      console.error(error);\n      throw error;\n    }\n  }\n\n  async getThread(_id) {\n    let dId = Post.decodeId(_id);\n    let sq = await nsdb.search({\n      query: {\n        createdAt: {\n          $gte: dId.timeGte,\n          $lte: dId.timeLte\n        },\n        transaction: {\n          $regex: `^${dId.txid32}`\n        }\n      }\n    });\n    if (sq.payload.length == 0) return undefined;\n    let posts = [];\n    let op = Post.fromDbObject(sq.payload[0]);\n    sq = {\n      query: {\n        threadUuid: op.threadUuid,\n        sub: op.sub\n      },\n      account: eos.accountName || ''\n    };\n\n    do {\n      sq = await nsdb.search(sq);\n      posts = [...posts, ...sq.payload.map(o => Post.fromDbObject(o))];\n    } while (sq.cursorId);\n\n    let thread = new Thread();\n    thread.init(posts);\n    thread.normalize();\n    return thread;\n  }\n\n  async getPostsForSubs(subs) {\n    let q = {\n      $in: subs.map(sub => sub.toLowerCase())\n    };\n\n    if (subs.length == 1 && subs[0] == 'all') {\n      q = {\n        $nin: []\n      }; // filtered subs from all sub\n    }\n\n    const query = await nsdb.search({\n      query: {\n        sub: q,\n        parentUuid: '' // top-level only\n\n      },\n      sort: {\n        createdAt: -1\n      },\n      account: eos.accountName || ''\n    });\n    return query.payload.map(o => Post.fromDbObject(o));\n  }\n\n  async getPostsForTags(tags, cursorId = undefined, count = 0, limit = 20, threadOnly = true) {\n    const searchQuery = {\n      query: {\n        tags: {\n          $in: tags.map(tag => tag.toLowerCase())\n        }\n      },\n      sort: {\n        createdAt: -1\n      },\n      account: eos.accountName || '',\n      cursorId,\n      count,\n      limit\n    };\n\n    if (threadOnly) {\n      searchQuery.query['parentUuid'] = '';\n    }\n\n    const query = await nsdb.search(searchQuery);\n    let posts = query.payload.map(o => Post.fromDbObject(o));\n    return {\n      posts,\n      cursorId: query.cursorId\n    };\n  }\n  /**\r\n   * Returns all the posts in which the user was\r\n   * tagged in (mentions).\r\n   */\n\n\n  async getPostsForNotifications(postPublicKey, lastCheckedNotifications, cursorId = undefined) {\n    try {\n      return await nsdb.search({\n        query: {\n          createdAt: {\n            $gte: lastCheckedNotifications\n          },\n          mentions: {\n            $in: [postPublicKey]\n          }\n        },\n        cursorId\n      });\n    } catch (error) {\n      throw error;\n    }\n  }\n\n}\n;","map":null,"metadata":{},"sourceType":"module"}