{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/esm/initializerWarningHelper\";\n\nvar _dec, _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _temp;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { action, computed, observable, set } from 'mobx';\nimport { task } from 'mobx-task';\nimport { Messages } from \"../constants/globals\";\nimport { generateUuid, getAttachmentValue } from \"../utils\";\nimport { getNewAuthStore, getPostsStore, getUiStore } from \"../stores\";\nimport PostModel from \"./postModel\";\nimport { discussions } from \"../novusphere-js\";\nexport let ReplyModel = (_dec = task.resolved, (_class = (_temp = class ReplyModel {\n  // the post replying to\n  constructor(post, map) {\n    _initializerDefineProperty(this, \"uid\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"content\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"open\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"map\", _descriptor4, this);\n\n    this.newAuthStore = void 0;\n    this.postStore = void 0;\n    this.uiStore = void 0;\n\n    _initializerDefineProperty(this, \"post\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"setContent\", _descriptor6, this);\n\n    _initializerDefineProperty(this, \"clearContent\", _descriptor7, this);\n\n    _initializerDefineProperty(this, \"onSubmit\", _descriptor8, this);\n\n    _initializerDefineProperty(this, \"toggleOpen\", _descriptor9, this);\n\n    this.uid = post.uuid;\n    this.map = map;\n    this.newAuthStore = getNewAuthStore();\n    this.postStore = getPostsStore();\n    this.uiStore = getUiStore();\n  }\n\n  get inlineTags() {\n    return this.content.match(/#([^\\s.,;:!?]+)/gi);\n  }\n\n  get inlineMentions() {\n    return this.content.match(/\\[@(.*?)]\\(.*?\\)/gi);\n  }\n\n  get inlineMentionHashes() {\n    const regex = new RegExp(/\\(?EOS.*\\)?\\w/, 'gi');\n    return this.inlineMentions.map(items => {\n      return items.match(regex)[0];\n    });\n  }\n\n}, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"uid\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '';\n  }\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"content\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '';\n  }\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"open\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return false;\n  }\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"map\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, \"post\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return null;\n  }\n}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, \"setContent\", [action], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return content => {\n      this.content = content;\n    };\n  }\n}), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, \"clearContent\", [action], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return () => {\n      this.content = '';\n    };\n  }\n}), _applyDecoratedDescriptor(_class.prototype, \"inlineTags\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"inlineTags\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"inlineMentions\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"inlineMentions\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"inlineMentionHashes\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"inlineMentionHashes\"), _class.prototype), _descriptor8 = _applyDecoratedDescriptor(_class.prototype, \"onSubmit\", [_dec], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return async () => {\n      if (!this.newAuthStore.hasAccount) {\n        this.uiStore.showToast('You must be logged in to comment', 'error');\n        return;\n      }\n\n      let post;\n\n      if (!this.post) {\n        post = this.map[this.uid];\n      }\n\n      if (!this.content) {\n        throw Error(Messages.ERROR.POST_EMPTY);\n      }\n\n      const generatedUid = generateUuid();\n      const posterName = this.newAuthStore.posterName;\n      const reply = {\n        poster: null,\n        displayName: null,\n        title: '',\n        content: this.content,\n        sub: post.sub,\n        chain: 'eos',\n        mentions: this.inlineMentionHashes,\n        tags: [post.sub],\n        id: generatedUid,\n        uuid: generatedUid,\n        parentUuid: post.uuid,\n        threadUuid: post.threadUuid,\n        attachment: getAttachmentValue(this.content),\n        upvotes: 0,\n        downvotes: 0\n      };\n\n      if (posterName === this.newAuthStore.displayName.bk) {\n        reply.poster = undefined;\n        reply.displayName = posterName;\n      }\n\n      if (posterName === this.newAuthStore.displayName.scatter) {\n        reply.poster = posterName;\n        reply.displayName = posterName;\n      }\n\n      let tags = this.inlineTags;\n\n      if (tags && tags.length) {\n        tags = tags.map(tag => tag.replace('#', ''));\n        reply.tags = [...reply.tags, ...tags];\n      }\n\n      try {\n        const activeThread = this.postStore.activeThread;\n\n        if (activeThread) {\n          const model = new PostModel(reply);\n          const signedReply = model.sign(this.newAuthStore.postPriv);\n          const confirmedReply = await discussions.post(signedReply);\n          set(activeThread, {\n            map: _objectSpread({}, activeThread.map, {\n              [reply.id]: new PostModel(_objectSpread({}, confirmedReply, {\n                upvotes: reply.displayName && reply.poster ? 1 : 0,\n                myVote: reply.displayName && reply.poster ? 1 : 0\n              }))\n            })\n          });\n          this.content = '';\n          this.toggleOpen();\n          this.uiStore.showToast('Your reply has been submitted!', 'success');\n        } else {\n          this.uiStore.showToast('Failed to submit your reply', 'error');\n        }\n      } catch (error) {\n        this.uiStore.showToast(error.message, 'error');\n        throw error;\n      }\n    };\n  }\n}), _descriptor9 = _applyDecoratedDescriptor(_class.prototype, \"toggleOpen\", [action], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return () => {\n      this.open = !this.open;\n    };\n  }\n})), _class));","map":null,"metadata":{},"sourceType":"module"}