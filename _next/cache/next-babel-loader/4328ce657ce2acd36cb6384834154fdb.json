{"ast":null,"code":"import _initializerDefineProperty from \"@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/esm/initializerWarningHelper\";\n\nvar _dec, _dec2, _dec3, _dec4, _dec5, _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _class2, _temp;\n\nimport { BaseStore, getOrCreateStore } from 'next-mobx-wrapper';\nimport { action, computed, observable, reaction } from 'mobx';\nimport { task } from 'mobx-task';\nimport { getNewAuthStore } from \"./index\";\nimport { discussions } from \"../novusphere-js\";\nimport { persist } from 'mobx-persist';\nimport FeedModel from \"../models/feedModel\";\nimport { sleep } from \"../utils\";\nlet Notifications = (_dec = action.bound, _dec2 = action.bound, _dec3 = action.bound, _dec4 = action.bound, _dec5 = action.bound, (_class = (_temp = _class2 = class Notifications extends BaseStore {\n  // the time last checked\n  // set default\n  constructor() {\n    super();\n\n    _initializerDefineProperty(this, \"lastCheckedNotifications\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"cursorId\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"notifications\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"unreadCount\", _descriptor4, this);\n\n    this.authStore = getNewAuthStore();\n    reaction(() => this.authStore.hasAccount, hasAccount => {\n      if (hasAccount) {\n        this.fetchNotifications();\n      }\n    }, {\n      fireImmediately: true\n    });\n  }\n\n  get notificationsAsArray() {\n    return Array.from(this.notifications.values());\n  }\n\n  get firstSetOfNotifications() {\n    return this.notificationsAsArray.slice(0, Notifications.notificationMaximumCount - 1);\n  }\n\n  get hasMoreThanQueriedNotifications() {\n    return this.cursorId !== 0;\n  }\n\n  get hasNotifications() {\n    return this.unreadCount > 0;\n  }\n\n  get notificationCount() {\n    const count = this.unreadCount;\n\n    if (count > Notifications.notificationMaximumCount) {\n      return `${Notifications.notificationMaximumCount}+`;\n    }\n\n    return count;\n  }\n\n  setTimeStamp() {\n    this.lastCheckedNotifications = Date.now();\n  }\n\n  resetUnreadCount() {\n    this.unreadCount = 0;\n  }\n\n  clearNotifications() {\n    this.resetUnreadCount();\n    this.notifications.clear();\n    this.cursorId = 0;\n  }\n\n  async fetchNotifications(time = this.lastCheckedNotifications) {\n    let defaultCursorId = this.cursorId;\n\n    if (defaultCursorId === 0) {\n      defaultCursorId = undefined;\n    }\n\n    try {\n      const {\n        payload,\n        cursorId\n      } = await discussions.getPostsForNotifications(this.authStore.activePublicKey, time, defaultCursorId);\n\n      if (time === 0) {\n        this.lastCheckedNotifications = Date.now();\n        this.cursorId = cursorId;\n        return payload;\n      } else {\n        payload.forEach(notification => {\n          this.notifications.set(notification.uuid, notification);\n        });\n        this.lastCheckedNotifications = Date.now();\n        this.cursorId = cursorId;\n        this.unreadCount = this.notifications.size;\n      }\n\n      return payload;\n    } catch (error) {\n      throw error;\n    }\n  }\n\n  async fetchNotificationsAsFeed() {\n    try {\n      await sleep(500);\n      const payload = await this.fetchNotifications(0);\n      return payload.map(post => new FeedModel(post));\n    } catch (error) {\n      throw error;\n    }\n  }\n\n}, _class2.notificationMaximumCount = 5, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"lastCheckedNotifications\", [persist, observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return -1;\n  }\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"cursorId\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 0;\n  }\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"notifications\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return observable.map();\n  }\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"unreadCount\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return 0;\n  }\n}), _applyDecoratedDescriptor(_class.prototype, \"notificationsAsArray\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"notificationsAsArray\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"firstSetOfNotifications\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"firstSetOfNotifications\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"hasMoreThanQueriedNotifications\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"hasMoreThanQueriedNotifications\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"hasNotifications\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"hasNotifications\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"notificationCount\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"notificationCount\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"setTimeStamp\", [_dec], Object.getOwnPropertyDescriptor(_class.prototype, \"setTimeStamp\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"resetUnreadCount\", [_dec2], Object.getOwnPropertyDescriptor(_class.prototype, \"resetUnreadCount\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"clearNotifications\", [_dec3], Object.getOwnPropertyDescriptor(_class.prototype, \"clearNotifications\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"fetchNotifications\", [task, _dec4], Object.getOwnPropertyDescriptor(_class.prototype, \"fetchNotifications\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"fetchNotificationsAsFeed\", [task, _dec5], Object.getOwnPropertyDescriptor(_class.prototype, \"fetchNotificationsAsFeed\"), _class.prototype)), _class));\nexport { Notifications as default };\nexport const getNotificationsStore = getOrCreateStore('notificationsStore', Notifications);","map":null,"metadata":{},"sourceType":"module"}