{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nconst fetch = require('node-fetch');\n\nimport { Api, JsonRpc } from 'eosjs';\nimport { JsSignatureProvider } from 'eosjs/dist/eosjs-jssig';\nimport { getTokens, getAccountTokens } from \"./tokens\";\nexport const DEFAULT_EOS_NETWORK = {\n  host: 'eos.greymass.com',\n  port: 443,\n  protocol: 'https',\n  chainId: 'aca376f206b8fc25a6ed44dbdc66547c36c6c33e3a119ffbeaef943642f0e906'\n};\nexport class EOS {\n  get accountName() {\n    return this.wallet && this.wallet.auth ? this.wallet.auth.accountName : undefined;\n  }\n\n  get auth() {\n    return this.wallet ? this.wallet.auth : undefined;\n  }\n\n  get api() {\n    if (this.wallet) return this.wallet.eosApi;\n    if (this._api) return this._api;\n    const net = DEFAULT_EOS_NETWORK;\n    const rpc = new JsonRpc(`${net.protocol}://${net.host}:${net.port}`, {\n      fetch\n    });\n    const signatureProvider = new JsSignatureProvider([]);\n    const api = new Api({\n      rpc,\n      signatureProvider,\n      chainId: net.chainId,\n      textDecoder: new TextDecoder(),\n      textEncoder: new TextEncoder()\n    });\n    this._api = api;\n    return api;\n  }\n\n  constructor() {\n    this.accessContext = void 0;\n    this.wallet = void 0;\n    this.discoveryData = void 0;\n    this.tokens = void 0;\n    this._api = void 0;\n  }\n\n  async init(network) {\n    if (process.browser) {\n      // client?\n      const transit = await import('eos-transit');\n      const scatter = await import('eos-transit-scatter-provider');\n      const lynx = await import('eos-transit-lynx-provider');\n      const tokenpocket = await import('eos-transit-tokenpocket-provider');\n      const meetone = await import('eos-transit-meetone-provider');\n      this.accessContext = transit.initAccessContext({\n        appName: 'discussions',\n        network: network,\n        walletProviders: [lynx.default(), tokenpocket.default(), meetone.default(), scatter.default()]\n      });\n    }\n\n    this.tokens = await getTokens();\n  }\n\n  async tryConnectWallet(selectedProvider) {\n    if (!this.accessContext) return;\n    const wallet = this.accessContext.initWallet(selectedProvider);\n    await wallet.connect();\n    if (this.wallet) throw new Error('Already have a wallet present');else if (!wallet.connected) throw new Error('Failed to connect');\n    const discoveryData = await wallet.discover({\n      pathIndexList: [0]\n    }); // TO-DO: ledger\n\n    this.wallet = wallet;\n    this.discoveryData = discoveryData;\n    console.log('Detected and connected to ' + selectedProvider.meta.name);\n\n    if (discoveryData.keyToAccountMap.length > 0) {\n      console.log(discoveryData);\n    }\n  }\n\n  async detectWallet(attempts = 1) {\n    if (!this.accessContext) return false;\n    const providers = this.accessContext.getWalletProviders();\n\n    for (let i = 0; i < attempts && !this.wallet; i++) {\n      console.log('Wallet detection round ' + i);\n\n      if (navigator.userAgent.toLowerCase().includes('meet.one')) {\n        const provider = providers.find(p => p.id == 'meetone_provider');\n\n        if (provider) {\n          try {\n            await this.tryConnectWallet(provider);\n          } catch (ex) {\n            console.log('Undetected ' + provider.id);\n          }\n        }\n      } else {\n        var promises = providers.map(p => new Promise(async resolve => {\n          try {\n            await this.tryConnectWallet(p);\n          } catch (ex) {\n            console.log('Undetected ' + p.id);\n          }\n\n          return resolve();\n        }));\n        await Promise.all(promises);\n      }\n    }\n\n    return this.wallet;\n  }\n\n  async transact(actions) {\n    if (!this.wallet) return undefined;\n    const auth = this.auth;\n    if (!auth) return undefined;\n\n    if (!Array.isArray(actions)) {\n      actions = [actions]; // single action\n    }\n\n    let transitActions = actions.map(a => _objectSpread({}, a, {\n      authorization: [{\n        actor: auth.accountName,\n        permission: auth.permission\n      }]\n    }));\n\n    try {\n      let tx = await this.wallet.eosApi.transact({\n        actions: transitActions\n      }, {\n        broadcast: true,\n        blocksBehind: 3,\n        expireSeconds: 180\n      });\n      return tx ? tx.transaction_id : undefined;\n    } catch (error) {\n      console.error(error);\n      throw error;\n    }\n  }\n\n  async getTransaction(txid) {\n    if (!this.wallet) return undefined;\n    const eos = this.wallet.eosApi;\n    const tx = await eos.rpc.history_get_transaction(txid);\n    return tx;\n  }\n\n  async getToken(account, symbol) {\n    if (!this.tokens) return undefined;\n    return this.tokens.find(t => t.account == account && t.symbol == symbol);\n  }\n  /**\r\n   * Fetch a list of suggested users for mentions.\r\n   * @param accountPartial {string} - The partial name of the account\r\n   * @param limit \r\n   * @returns {string[]}\r\n   */\n\n\n  async getSuggestAccounts(accountPartial, _limit = 10) {\n    let request = await fetch(`https://eos.greymass.com/v1/chain/get_table_by_scope`, {\n      method: 'POST',\n      body: JSON.stringify({\n        \"code\": \"eosio\",\n        \"table\": \"userres\",\n        \"lower_bound\": accountPartial,\n        \"upper_bound\": accountPartial.padEnd(12, 'z'),\n        \"limit\": 5\n      })\n    });\n    let json = await request.json();\n    return json.rows.map(d => d.scope);\n  }\n  /**\r\n   * Returns non-zero balances for a given username.\r\n   * @param account {string} - The name of the account (username)\r\n   * @returns {IAccountBalance[]}\r\n   */\n\n\n  async getAccountTokens(account) {\n    if (!this.tokens) return [];\n    return getAccountTokens(account, this.tokens);\n  }\n\n  async login(account, permission) {\n    if (!this.wallet) return false;\n    await this.wallet.login(account, permission);\n\n    if (this.auth) {\n      window.dispatchEvent(new Event('eosAccountChange'));\n      return true;\n    }\n\n    return false;\n  }\n\n  async logout() {\n    if (!this.wallet) return;\n    await this.wallet.logout();\n\n    if (!this.auth) {\n      window.dispatchEvent(new Event('eosAccountChange'));\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}