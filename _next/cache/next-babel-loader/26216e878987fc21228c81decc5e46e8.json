{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/esm/initializerWarningHelper\";\n\nvar _dec, _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _temp;\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport Thread from \"../novusphere-js/discussions/thread\";\nimport { Post } from \"../novusphere-js/discussions/post\";\nimport { action, computed, observable } from 'mobx';\nimport { computedFn } from 'mobx-utils';\nimport { ReplyModel } from \"./replyModel\";\nimport _ from 'lodash';\nimport PostModel from \"./postModel\";\nimport { discussions } from \"../novusphere-js\"; // import { discussions } from '@novuspherejs'\n\nexport var ThreadModel = (_dec = observable.deep, (_class = (_temp =\n/*#__PURE__*/\nfunction () {\n  _createClass(ThreadModel, [{\n    key: \"totalReplies\",\n    get: function get() {\n      var map = Object.keys(this.map);\n\n      if (map.length) {\n        return map.length - 1;\n      }\n\n      return 0;\n    }\n    /**\r\n     * Get the reply box model for a particular post uid\r\n     * @return {ReplyModel}\r\n     */\n\n  }]);\n\n  /**\r\n   * ReplyBox box open status for a particular post id\r\n   */\n  function ThreadModel(thread) {\n    var _this = this;\n\n    _classCallCheck(this, ThreadModel);\n\n    _initializerDefineProperty(this, \"map\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"openingPost\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"uuid\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"title\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"sub\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"replies\", _descriptor6, this);\n\n    this.replyBoxStatuses = observable.map();\n    this.rbModel = computedFn(function (post) {\n      var uid = post.uuid;\n\n      if (_this.replyBoxStatuses.has(uid)) {\n        return _this.replyBoxStatuses.get(uid);\n      }\n\n      var model;\n\n      if (_this.map[uid]) {\n        model = new ReplyModel(_this.map[uid], _this.map);\n      } else {\n        model = new ReplyModel(post, _this.map);\n      }\n\n      _this.replyBoxStatuses.set(uid, model);\n\n      return model;\n    });\n    this.getRepliesFromMap = computedFn(function (uid) {\n      if (_this.map[uid]) {\n        return _.filter(_this.map, function (post, index) {\n          return post.parentUuid === uid;\n        });\n      }\n\n      return [];\n    });\n\n    this.toggleReplyBoxStatus = function (uid) {\n      var replyModel;\n\n      if (_this.replyBoxStatuses.has(uid)) {\n        replyModel = _this.replyBoxStatuses.get(uid);\n        replyModel.toggleOpen();\n\n        _this.replyBoxStatuses.set(uid, replyModel);\n      } else {\n        if (_this.map[uid]) {\n          _this.replyBoxStatuses.set(uid, new ReplyModel(_this.map[uid], _this.map));\n        }\n      }\n    };\n\n    _initializerDefineProperty(this, \"vote\", _descriptor7, this);\n\n    if (!(thread instanceof Post) || thread instanceof Thread) {\n      this.openingPost = new PostModel(thread.openingPost);\n      this.uuid = thread.openingPost.uuid;\n      var map = {};\n      Object.keys(thread.map).map(function (id) {\n        map[id] = new PostModel(thread.map[id]);\n      });\n      this.map = map;\n      this.title = thread.openingPost.title;\n      this.sub = thread.openingPost.sub;\n    } else {\n      this.openingPost = thread;\n      this.uuid = thread.uuid;\n      this.title = thread.title;\n    }\n    /**\r\n     * Set reply box open for the opening post by default\r\n     */\n\n\n    var openingPostReplyModel = new ReplyModel(this.openingPost, this.map);\n    openingPostReplyModel.toggleOpen();\n    this.replyBoxStatuses.set(this.uuid, openingPostReplyModel);\n  }\n\n  _createClass(ThreadModel, [{\n    key: \"openingPostReplies\",\n    get: function get() {\n      var _this2 = this;\n\n      var openingPostReplies = this.getRepliesFromMap(this.uuid);\n      return openingPostReplies.map(function (reply) {\n        return _objectSpread({}, reply, {\n          replies: _this2.getRepliesFromMap(reply.uuid)\n        });\n      });\n    }\n    /**\r\n     * Toggle the status of the reply box\r\n     * @param {string} uid\r\n     * @return {void}\r\n     */\n\n  }]);\n\n  return ThreadModel;\n}(), _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"map\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"openingPost\", [_dec], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"uuid\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"title\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, \"sub\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, \"replies\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _applyDecoratedDescriptor(_class.prototype, \"totalReplies\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"totalReplies\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"openingPostReplies\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"openingPostReplies\"), _class.prototype), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, \"vote\", [action], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function initializer() {\n    var _this3 = this;\n\n    return (\n      /*#__PURE__*/\n      function () {\n        var _ref = _asyncToGenerator(\n        /*#__PURE__*/\n        _regeneratorRuntime.mark(function _callee(uuid, myNewVote) {\n          var type;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  type = myNewVote === 1 ? 'upvotes' : 'downvotes';\n                  _context.prev = 1;\n                  _context.next = 4;\n                  return discussions.vote(uuid, myNewVote);\n\n                case 4:\n                  // opening post\n                  if (uuid === _this3.uuid) {\n                    if (_this3.openingPost['myVote'] === 0) {\n                      _this3.openingPost[type] = _this3.openingPost[type] + myNewVote;\n                      _this3.openingPost['myVote'] = myNewVote;\n                    } else if (_this3.openingPost['myVote'] === 1) {\n                      _this3.openingPost['upvotes'] = _this3.openingPost['upvotes'] - 1;\n                      _this3.openingPost['myVote'] = 0;\n                    } else if (_this3.openingPost['myVote'] === -1) {\n                      _this3.openingPost['downvotes'] = _this3.openingPost['downvotes'] + 1;\n                      _this3.openingPost['myVote'] = 0;\n                    }\n                  }\n\n                  if (_this3.map) {\n                    if (_this3.map[uuid].myVote === 0) {\n                      _this3.map[uuid][type] = _this3.map[uuid][type] + myNewVote;\n                      _this3.map[uuid].myVote = myNewVote;\n                    } else if (_this3.map[uuid].myVote === 1) {\n                      _this3.map[uuid]['upvotes'] = _this3.map[uuid]['upvotes'] - 1;\n                      _this3.map[uuid].myVote = 0;\n                    } else if (_this3.map[uuid].myVote === -1) {\n                      _this3.map[uuid]['downvotes'] = _this3.map[uuid]['downvotes'] + 1;\n                      _this3.map[uuid].myVote = 0;\n                    }\n                  }\n\n                  _context.next = 12;\n                  break;\n\n                case 8:\n                  _context.prev = 8;\n                  _context.t0 = _context[\"catch\"](1);\n                  console.log(_context.t0);\n                  throw _context.t0;\n\n                case 12:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[1, 8]]);\n        }));\n\n        return function (_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }()\n    );\n  }\n})), _class));","map":null,"metadata":{},"sourceType":"module"}