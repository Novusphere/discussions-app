{"ast":null,"code":"import _initializerDefineProperty from \"@babel/runtime/helpers/esm/initializerDefineProperty\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/esm/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/esm/initializerWarningHelper\";\n\nvar _dec, _dec2, _class, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _temp;\n\nimport { action, computed, observable } from 'mobx';\nimport { discussions } from \"../novusphere-js\";\nimport { task } from 'mobx-task';\nimport { BaseStore, getOrCreateStore } from 'next-mobx-wrapper';\nimport { CreateForm } from \"../components\";\nimport { getTagStore } from \"./tag\";\nimport { getNewAuthStore, getUiStore } from \"./\";\nimport { generateUuid, getAttachmentValue, getIdenticon, pushToThread, sleep } from \"../utils\";\nimport { ThreadModel } from \"../models/threadModel\";\nimport FeedModel from \"../models/feedModel\";\nimport _ from 'lodash';\nlet Posts = (_dec = observable.deep, _dec2 = action.bound, (_class = (_temp = class Posts extends BaseStore {\n  // all posts by filter\n  // when creating a new post\n\n  /**\r\n   * Manage getRepliesFromMap within a post (not opening post)\r\n   */\n  // which post the user is currently replying to\n  // which post the user is currently replying to\n\n  /**\r\n   * Manage getRepliesFromMap of the opening post\r\n   */\n  constructor(props) {\n    super(props);\n\n    _initializerDefineProperty(this, \"posts\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"postsPosition\", _descriptor2, this);\n\n    _initializerDefineProperty(this, \"preview\", _descriptor3, this);\n\n    _initializerDefineProperty(this, \"activeThreadId\", _descriptor4, this);\n\n    _initializerDefineProperty(this, \"newPostData\", _descriptor5, this);\n\n    _initializerDefineProperty(this, \"replyingPostUUID\", _descriptor6, this);\n\n    _initializerDefineProperty(this, \"replyingPostContent\", _descriptor7, this);\n\n    _initializerDefineProperty(this, \"openingPostReplyContent\", _descriptor8, this);\n\n    _initializerDefineProperty(this, \"activeThread\", _descriptor9, this);\n\n    this.tagsStore = void 0;\n    this.uiStore = void 0;\n    this.newAuthStore = void 0;\n\n    this.resetPositionAndPosts = () => {\n      this.posts = [];\n      this.postsPosition = {\n        items: 0,\n        cursorId: undefined\n      };\n    };\n\n    _initializerDefineProperty(this, \"getPostsByTag\", _descriptor10, this);\n\n    _initializerDefineProperty(this, \"getThreadById\", _descriptor11, this);\n\n    _initializerDefineProperty(this, \"vote\", _descriptor12, this);\n\n    _initializerDefineProperty(this, \"clearPreview\", _descriptor13, this);\n\n    this.tagsStore = getTagStore();\n    this.uiStore = getUiStore();\n    this.newAuthStore = getNewAuthStore(); // refresh posts on logged in\n    // so we can show upvotes/downvotes by the user\n    // reaction(\n    //     () => this.newAuthStore.hasAccount,\n    //     async hasAccount => {\n    //         if (hasAccount) {\n    //             if (this.activeThread) {\n    //                 this.getAndSetThread(this.activeThreadId)\n    //             }\n    //         }\n    //     }\n    // )\n  }\n\n  /**\r\n   * Threads shown in the feed for an active tag/sub\r\n   */\n  get feedThreads() {\n    if (!this.posts || !this.posts.length) {\n      return null;\n    }\n\n    return this.posts.filter(post => post.parentUuid === '').map(post => new FeedModel(post));\n  }\n\n  async getAndSetThread(id) {\n    try {\n      const thread = await this.getThreadById(id);\n\n      if (!thread) {\n        return null;\n      }\n\n      this.activeThread = thread;\n      this.activeThreadId = id;\n      return this.activeThread;\n    } catch (error) {\n      console.log('Class: Posts, Function: getAndSetThread, Line 123 error: ', error);\n      throw error;\n    }\n  }\n  /**\r\n   * Get the list of users in the current thread for tagging.\r\n   * TODO: Add users the current active user follows as well\r\n   * @returns {id: string, value: string}[]\r\n   */\n\n\n  get getPossibleUsersToTag() {\n    if (!this.activeThread) return [];\n    return _.uniqBy(_.map(_.filter(this.activeThread.map, posts => posts.pub.length), posts => {\n      let poster = posts.poster;\n\n      if (poster === 'eosforumanon') {\n        poster = posts.displayName;\n      }\n\n      let imageData = getIdenticon();\n\n      if (posts.pub && posts.pub.length) {\n        imageData = getIdenticon(posts.pub);\n      }\n\n      return {\n        id: posts.pub,\n        value: poster,\n        icon: imageData\n      };\n    }), option => option.id);\n  }\n\n  get subFields() {\n    return {\n      name: 'sub',\n      label: 'Sub',\n      placeholder: 'Select a sub',\n      rules: 'required',\n      type: 'dropdown',\n      hideLabels: true,\n      extra: {\n        options: [{\n          value: 'all',\n          label: 'all'\n        }, ...Array.from(this.tagsStore.tags.values()).filter(tag => !tag.root).map(tag => ({\n          value: tag.name,\n          label: tag.name\n        }))]\n      }\n    };\n  }\n\n  get newPostForm() {\n    return new CreateForm({}, [{\n      name: 'title',\n      label: `Title`,\n      placeholder: 'Enter a post title',\n      rules: 'required|string|min:5|max:45',\n      hideLabels: true\n    }, // {\n    //     name: 'sub',\n    //     label: 'Sub',\n    //     placeholder: 'Select a sub',\n    //     rules: 'required',\n    //     type: 'dropdown',\n    //     hideLabels: true,\n    //     extra: {\n    //         options: [\n    //             { value: 'all', label: 'all' },\n    //             ...Array.from(this.tagsStore.tags.values())\n    //                 .filter(tag => !tag.root)\n    //                 .map(tag => ({\n    //                     value: tag.name,\n    //                     label: tag.name,\n    //                 })),\n    //         ],\n    //     },\n    // },\n    {\n      name: 'content',\n      label: 'Content',\n      hideLabels: true,\n      placeholder: 'Enter your content',\n      // rules: 'required',\n      type: 'richtext'\n    }, // {\n    //     name: 'attachmentType',\n    //     type: 'radiogroup',\n    //     value: 'No Attachment',\n    //     hideLabels: true,\n    //     extra: {\n    //         options: [\n    //             {\n    //                 value: 'No Attachment',\n    //                 onClick: ({ form }) => {\n    //                     form.$('urlType').$extra.render = false\n    //                     form.$('hash').$extra.render = false\n    //                     form.$('txidType').$extra.render = false\n    //\n    //                     // reset values\n    //                     form.$('urlType').value = ''\n    //                     form.$('hash').value = ''\n    //                     form.$('txidType').value = ''\n    //                 },\n    //             },\n    //             {\n    //                 value: 'URL',\n    //                 onClick: ({ form }) => {\n    //                     form.$('urlType').$extra.render = true\n    //                     form.$('hash').$extra.render = true\n    //                     form.$('txidType').$extra.render = false\n    //                 },\n    //             },\n    //             {\n    //                 value: 'IPFS',\n    //                 onClick: ({ form }) => {\n    //                     form.$('urlType').$extra.render = true\n    //                     form.$('hash').$extra.render = true\n    //                     form.$('txidType').$extra.render = false\n    //                 },\n    //             },\n    //             {\n    //                 value: 'TXID',\n    //                 onClick: ({ form }) => {\n    //                     form.$('urlType').$extra.render = false\n    //                     form.$('hash').$extra.render = true\n    //                     form.$('txidType').$extra.render = true\n    //                 },\n    //             },\n    //         ],\n    //     },\n    // },\n    // {\n    //     name: 'urlType',\n    //     type: 'radiogroup',\n    //     extra: {\n    //         render: false,\n    //         options: [\n    //             {\n    //                 value: 'link',\n    //             },\n    //             {\n    //                 value: 'iframe',\n    //             },\n    //             {\n    //                 value: 'mp4',\n    //             },\n    //             {\n    //                 value: 'mp3',\n    //             },\n    //         ],\n    //     },\n    // },\n    // {\n    //     name: 'txidType',\n    //     type: 'radiogroup',\n    //     extra: {\n    //         render: false,\n    //         options: [\n    //             {\n    //                 value: 'referendum',\n    //             },\n    //         ],\n    //     },\n    // },\n    // {\n    //     name: 'hash',\n    //     label: 'Hash',\n    //     placeholder: 'IPFS Hash / URL / TXID',\n    //     extra: {\n    //         render: false,\n    //     },\n    // },\n    {\n      name: 'buttons',\n      type: 'button',\n      hideLabels: true,\n      extra: {\n        options: [// {\n        //     value: 'Preview',\n        //     className: 'white bg-gray',\n        //     title: 'Preview the post before submitting',\n        //     onClick: form => {\n        //         if (form.isValid) {\n        //             console.log(this.newPostData)\n        //             // this.preview = form.values()\n        //             // this.preview.sub = {\n        //             //     value: this.newPostData.sub,\n        //             //     label: this.newPostData.sub,\n        //             // }\n        //         }\n        //     },\n        // },\n        {\n          value: 'Post ID',\n          title: 'Post with an anonymous ID'\n        }, {\n          value: 'Post',\n          disabled: !this.newAuthStore.hasAccount,\n          title: !this.newAuthStore.hasAccount ? 'You need to be logged in to post' : 'Post with your logged as ' + this.newAuthStore.posterName,\n          onClick: task.resolved(async form => {\n            if (!form.hasError && this.newPostData.sub.value) {\n              const post = form.values();\n              const uuid = generateUuid();\n              const posterName = this.newAuthStore.posterName;\n              const newPost = {\n                poster: null,\n                displayName: null,\n                title: post.title,\n                content: post.content,\n                sub: this.newPostData.sub.value,\n                chain: 'eos',\n                mentions: [],\n                tags: [this.newPostData.sub.value],\n                uuid: uuid,\n                parentUuid: '',\n                threadUuid: uuid,\n                attachment: getAttachmentValue(post),\n                createdAt: Date.now()\n              };\n\n              if (posterName === this.newAuthStore.displayName.bk) {\n                newPost.poster = undefined;\n                newPost.displayName = posterName;\n              }\n\n              if (posterName === this.newAuthStore.displayName.scatter) {\n                newPost.poster = posterName;\n                newPost.displayName = posterName;\n              }\n\n              const submittedPost = await discussions.post(newPost); // TODO: Add check to make sure the thread is actually posted onto the chain\n\n              await sleep(5000);\n              pushToThread(submittedPost);\n              this.uiStore.showToast('Your post has been created!', 'success');\n              this.clearPreview();\n            }\n          })\n        }]\n      }\n    }]);\n  }\n\n}, _temp), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"posts\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return [];\n  }\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"postsPosition\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return {\n      items: 0,\n      cursorId: undefined\n    };\n  }\n}), _descriptor3 = _applyDecoratedDescriptor(_class.prototype, \"preview\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return null;\n  }\n}), _descriptor4 = _applyDecoratedDescriptor(_class.prototype, \"activeThreadId\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '';\n  }\n}), _descriptor5 = _applyDecoratedDescriptor(_class.prototype, \"newPostData\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return {\n      sub: {\n        value: '',\n        label: ''\n      }\n    };\n  }\n}), _descriptor6 = _applyDecoratedDescriptor(_class.prototype, \"replyingPostUUID\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '';\n  }\n}), _descriptor7 = _applyDecoratedDescriptor(_class.prototype, \"replyingPostContent\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '';\n  }\n}), _descriptor8 = _applyDecoratedDescriptor(_class.prototype, \"openingPostReplyContent\", [observable], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return '';\n  }\n}), _descriptor9 = _applyDecoratedDescriptor(_class.prototype, \"activeThread\", [_dec], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor10 = _applyDecoratedDescriptor(_class.prototype, \"getPostsByTag\", [task], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return async tags => {\n      const {\n        posts,\n        cursorId\n      } = await discussions.getPostsForTags(tags, this.postsPosition.cursorId, this.postsPosition.items);\n      this.posts = [...this.posts, ...posts];\n      this.postsPosition = {\n        items: this.posts.length,\n        cursorId: cursorId\n      };\n      return this.posts;\n    };\n  }\n}), _applyDecoratedDescriptor(_class.prototype, \"feedThreads\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"feedThreads\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"getAndSetThread\", [task, _dec2], Object.getOwnPropertyDescriptor(_class.prototype, \"getAndSetThread\"), _class.prototype), _applyDecoratedDescriptor(_class.prototype, \"getPossibleUsersToTag\", [computed], Object.getOwnPropertyDescriptor(_class.prototype, \"getPossibleUsersToTag\"), _class.prototype), _descriptor11 = _applyDecoratedDescriptor(_class.prototype, \"getThreadById\", [task], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return async id => {\n      try {\n        const thread = await discussions.getThread(id);\n\n        if (!thread) {\n          return null;\n        }\n\n        return new ThreadModel(thread);\n      } catch (error) {\n        throw error;\n      }\n    };\n  }\n}), _descriptor12 = _applyDecoratedDescriptor(_class.prototype, \"vote\", [action], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return async (uuid, value) => {\n      try {\n        if (this.newAuthStore.hasAccount) {\n          await this.activeThread.vote(uuid, value);\n        }\n      } catch (error) {\n        throw error;\n      }\n    };\n  }\n}), _descriptor13 = _applyDecoratedDescriptor(_class.prototype, \"clearPreview\", [action], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: function () {\n    return () => {\n      this.preview = null;\n    };\n  }\n})), _class));\nexport { Posts as default };\nexport const getPostsStore = getOrCreateStore('postsStore', Posts);","map":null,"metadata":{},"sourceType":"module"}